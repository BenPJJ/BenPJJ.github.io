<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2018%2F05%2F26%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[选择器 无非分两种：1,标签选择器（*是特殊情况），可但标签，也可上下文多标签；2,属性选择器（id和class都是属性，特殊的属性）； 标签选择器1,多标签 例如：123456789101112div p&#123;&#125;选择一个祖先的所有子孙节点div &gt; p&#123;&#125;选择一个父元素的所有直属节点li + li&#123;&#125;选择某一个元素紧挨着的兄弟节点span ~ a&#123;&#125;选择某一个元素的所有同胞节点运用给菜单栏之间加下划线，以前的做法(给所用的li设，在指定最后的去掉)新用法：ul li+li&#123; border-top: 1px solid blue; &#125; 属性选择器css选择器是根据html节点的特性来设置的 两种方式：12img[title]&#123;&#125;只通过属性名选择input[type="button"]&#123;&#125;通过属性名和属性值选择]]></content>
  </entry>
  <entry>
    <title><![CDATA[css样式来源和层叠机制]]></title>
    <url>%2F2018%2F05%2F26%2Fcss%E6%A0%B7%E5%BC%8F%E6%9D%A5%E6%BA%90%E5%92%8C%E5%B1%82%E5%8F%A0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1,“层叠”的概念 层叠是CSS的核心机制 例如：1234567891011121314151617181920212223242526272829&lt;link rel="stylesheet" type="text/css" href="css/css1.css"&gt;&lt;style&gt; p&#123; color: blue; &#125; span&#123; color: blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;这是一个p&lt;/p&gt; &lt;span&gt;这是一个span&lt;/span&gt;&lt;/body&gt;css1.css&#123; p&#123; color: red; font-weight: bold; &#125; span&#123; color: red !important; &#125;&#125;最后显示的效果：p blue span red 知识点：!important!important为开发者提供了一个增加样式权重的方法。应当注意的是!important是对整条样式的声明，包括这个样式的属性和属性值。新写法：span{color: red !important;color :blue;} 2,层叠的规则覆盖的默认规则是后者覆盖前者，但是又一个特殊情况——!important。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器默认样式]]></title>
    <url>%2F2018%2F05%2F26%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1,理念上的转变 浏览器加载了html之后只为一件东西——dom树，浏览器把html变为dom树结构，就完成了对html的结构化。至于后来对视图的渲染，p是block、br换行，那是整合了css之后的事情。而浏览器整合css又是另一个路线，和解析html是分开的。这里的“css”就包含了浏览器默认样式。 一句话，浏览器将载入的html变为dom树，但是此时没有任何显示样式。所以显示的样式，都是css定义的，浏览器只会通过css来渲染视图样式。 2,block元素有：html,address, blockquote, body,dd,div, dl,dt,fieldset,form, frame,frameset, h1-h6, noframes, ol,p,ul,center, dir,hr,menu,pre没有设置block的元素，默认为inline显示。 不要再说div天生就是block——这句话应该换成：浏览器默认样式天生规定了div是block——所以才导致了div是block。是默认样式规定的，不是浏览器的内核规定的。 3,display: list-item例如：12345 &lt;div style="border: 1px solid #f0f0f0;padding: 5px"&gt; &lt;span style="display: list-item;"&gt;100&lt;/span&gt; &lt;span style="display: list-item"&gt;200&lt;/span&gt; &lt;span style="display: list-item"&gt;300&lt;/span&gt;&lt;/div&gt; ul-li为什么会默认显示成那种样子？——list-item才是“罪魁祸首”。 4,diplay:table和在容器尺寸上最大区别是什么（只是容器尺寸，不考虑内容区别）？div宽度和父容器相同，table宽度根据内容而定 5,display: table-cell多列布局,传统模式下大家都使用float来解决这一问题，但是float写出来的东西代码复杂，宽度调整不灵活，浏览器兼容性有问题。所以才有了新方案——table-cell，注意，IE6、7不行！ 6,body样式默认body{margin:8px;line-height:1.12}这里的line-height: 1.12是一个相对值，即是文字高度的1.12倍。 7,em和pxem是一个浏览器识别的长度单位，但是它不是绝对的、固定的，而是相对的。浏览器默认情况下令1em === 16px。 px是一个绝对的长度单位制，它永远不会改变。 8,粗体和斜体默认：123456789h5&#123;font-size: 0.83em;margin: 1.5em 0;&#125;h6&#123;font-size: 0.75em;margin: 1.67em 0;&#125;h1,h2,h3,h4,h5,h6,bstrong&#123;font-weight: bolder&#125;blockquote&#123;margin-left:40px;margin-right: 40px;&#125;i,cite,em,var,address&#123;font-style: italic&#125; 和有啥区别？为了加粗而加粗(被css(font-weight:bold;)取代了)，为了标明重点而加粗(更加偏向于语义化)。 和有啥区别？单纯斜体,偏强调,斜体，强调内容,(现在更多的流行用来放图标，没有实际意义搜索引擎更好抓取) 9,inline-block默认：1button,textarea,input,object,select&#123;display:inline-block;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[css-Float]]></title>
    <url>%2F2018%2F05%2F26%2Fcss(float)%2F</url>
    <content type="text"><![CDATA[误解和“误用” 绝大多数用float都是为了——横向排版、或者多列布局。这样使用确实是对float的一种误解和“误用”，因为float被设计出来的初衷是用于——文字环绕效果。 破坏性float的“破坏性”——float破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于：被设置了float的元素会脱离文档流。(通俗点就是被设置的元素不占空间了) 解决方法1234567div:after&#123; content:""; height:0; display:block; clear:both; visibility:hidden;&#125; 例如：1234567&lt;div style="border:1px solid blue;padding:5px;"&gt; &lt;img src="img.png"/&gt;&lt;/div&gt;对比 &lt;div style="border:1px solid blue;padding:5px"&gt; &lt;img src="img.png" style="float:left;"/&gt;&lt;/div&gt; 包裹性清空格为什么float适合用于网页排版（俗称“砌砖头”）？就是因为float排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。 “清空格”这一特性的根本原因是由于float会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没关系的，它就尽量的往一边去靠拢，能靠多近就靠多近，这就是清空格的本质。 解决float一系列问题清除float先介绍两个比较简单，但是不常用的解决方法： 1,为父元素添加overflow:hidden2,浮动父元素 3,第三种方法也不是很常用,clear:both,通过在所有浮动元素下方添加一个clear:both的元素，可以消除float的破坏性。(如：在浮动元素下加上,俗称骨灰级解决方法) 缺陷：改变了HTML结构 4,第四种方法是大家最需要掌握的,也是我推荐的，也是bootstrap正在用的——clearfix用法：定义一个.clearfix类，然后对float元素的父元素应用这一样式即可 12345678910.clearfix:after&#123; content:&apos;.&apos;; height:0; display:block; clear:both; visibility:hidden;&#125;.clearfix&#123; *zoom:1;//兼容IE低版本 &#125; 合理的使用float布局网页float做网页布局也是有许多技巧的，准确的应用会提高网页的灵活性。 1,三列布局三列布局(很明显的左、中、右) 布局方案1234567891011&lt;div class="clearfix" style="text-align:center;"&gt; &lt;div style="float:left;"&gt; 左侧内容(宽度可以不设置，因为float具有包裹性) &lt;/div&gt; &lt;div style="float:right;"&gt; 右侧内容(宽度可以不设置，因为float具有包裹性) &lt;/div&gt; &lt;div&gt; 中间内容(当页面宽度发生变化时,中间内容宽度会随之调整) &lt;/div&gt;&lt;/div&gt; 2,两列布局两列布局(分为左、右结构) 布局方案123456&lt;div style="float:left;"&gt; 左侧内容(宽度可以不设置，因为float具有包裹性)&lt;/div&gt;&lt;div style="margin-left:100px;"&gt; 右侧内容&lt;/div&gt; 3,BootStrap的栅格系统]]></content>
  </entry>
  <entry>
    <title><![CDATA[css-Display]]></title>
    <url>%2F2018%2F05%2F26%2Fcss(display)%2F</url>
    <content type="text"><![CDATA[网页的所有元素，除了“块”就是“流”，而且“流”都是包含在“块”里面的（最外层的body就是一个“块”）。 常用的属性有：none、block、inline、inline-block、inherit，其中inherit是继承父元素的样式。 特殊：list-item：通过它可以模拟li列表样式；table：也是一个“块”，但和block相比，table具有包裹性；table-cell：最新的多列布局解决方案； 包裹性：12345包裹性：元素的宽度会收缩到与内容宽度一致。拥有包裹性的元素：float浮动的元素position为absolute或fixed的元素display为inline-block, table-cell, table-caption, inline-flex的元素 1,inlineinline的标签，你设置宽度和高度是无效的 如何把inline元素转换成“块”元素？12341,一般想到的都是设置display:block;2,也可以display:table3,设置float浮动元素4,设置absolute/fixed 2,block一个元素设置了block，它就必须遵循盒子模型的规则。 3,inline-block外部看来是“流”，但是自身确实一个“块”。]]></content>
  </entry>
  <entry>
    <title><![CDATA[css3盒子模型]]></title>
    <url>%2F2018%2F05%2F25%2Fcss3%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1,什么是盒子模型 一种思维模型,内容(content)、填充(padding)、边框(border)、边界(margin)CSS盒子模式都具备这些属性。 2,盒子的宽度整个盒子的宽度是：（内容宽度 + border宽度 + padding宽度 + margin宽度）之和。设置的宽度都是内容宽度，不是整个盒子的宽度。 3,盒子模型设置宽度例如：123456&lt;div style="padding:10px;border:1px solid blue;margin:10px;width:300px;box-sizing:border-box;"&gt; 随便写点东西，装修盒子。&lt;/div&gt;这是内容的宽度等于contant=300-width-border*2-padding*2;而盒子的宽度等于 300 建议以后写样式：*{ margin: 0; padding: 0; box-sizing: border-box;} 4,纵向margin的重叠纵向的margin是会重叠的，大的会把小的“吃掉” 5,用div画“三角”例如：1234567div&#123; border: 10px solid; border-color: #333 transparent transparent transparent; width: 0;&#125;&lt;div&gt;&lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[js object的属性获取方式]]></title>
    <url>%2F2018%2F05%2F24%2Fjs%20object%E5%B1%9E%E6%80%A7%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[方式点object.name 括号object[“name”] 区别中括号法可以用变量作为属性名,而点方法不可以;中括号法可以用数字作为属性名,而点语法不可以;中括号法可以使用js的关键字和保留字作为属性名,而点语法不可以。]]></content>
  </entry>
  <entry>
    <title><![CDATA[css水平居中]]></title>
    <url>%2F2018%2F05%2F24%2Fcss%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[css水平居中 1,margin+width定义一个宽度，然后配合margin的左右值为’auto’ 优点：实现方法简单易懂，浏览器兼容性强； 缺点：扩展性差，无法自适应未知项情况。 2,inline-block要在元素的父容器中设置text-align的属性为“center”,然后在设置inline-block 优点：简单易懂，扩展性强； 缺点：需要额外处理inline-block的浏览器兼容性。 3,浮动优点：兼容性强，扩展性强； 缺点：实现原理较复杂。 4,绝对定位优点：扩展性强，兼容性强; 缺点：理解性难。 5,CSS3的flex 6,CSS3的fit-content]]></content>
  </entry>
  <entry>
    <title><![CDATA[css知多少]]></title>
    <url>%2F2018%2F05%2F24%2Fcss%E7%9F%A5%E5%A4%9A%E5%B0%91%2F</url>
    <content type="text"><![CDATA[问题 1,有些浏览器不完全支持css3，现在可以用哪个工具去检测浏览器是否支持，以及支持哪些项？ 解答：1234modernizr modernizr是一个 JavaScript 库，用于检测用户浏览器的 HTML5 与 CSS3 特性。工作原理：Modernizr 会在页面加载后立即检测特性；然后创建一个包含检测结果的 JavaScript 对象，同时在 html 元素加入方便你调整 CSS 的 class 名。 2,是否用过@import？ 解答：1234567引入CSS的方法有两种，一种是@import，一种是link @import url('地址');&lt;link href="地址" rel="stylesheet" type="text/css"/&gt;现在绝大部分的网站都采用后一种link方式，原因在于@import先加载HTML，后加载CSSlink先加载CSS，后加载HTML。所以前者加载网页会出现令浏览者以外的格式，后者则是带格式的加载网页。 3,display的block\inline\inline-block的区别 解答：1234567block 块级元素,自带换行符 可以设置宽高、margin、padding block元素宽度自动填满其父元素宽度,即使设置了宽,仍然会独占一行inline 行内元素,多个会自动排列一行 设置宽高无效 margin、padding水平方向有效，垂直方向无效inline-block 有宽高的水平排列 4,是否用过inline-block，IE6、7如何兼容？ 解答：1234567两种方法：1、先使用display:inline-block属性触发块元素，然后再定义display:inline，让块元素呈递为内联对象（两个display 要先后放在两个CSS声明中才有效果，这是IE的一个经典bug，如果先定义了display:inline-block，然后再将display设回 inline或block，layout不会消失）div01&#123;display:inline-block;&#125;div02&#123;display:inline-block;&#125;div01,div02&#123;*display:inline;&#125;2、直接让块元素设置为内联对象呈递（设置属性display:inline），然后触发块元素的layoutdiv&#123;display:inline-block;_zoom:1;*display:inline;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F05%2F23%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 例如1234^[0-9]+abc$^ 为匹配输入字符串的开始位置[0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。 普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 特殊字符例如1234567891011$ 匹配输入字符串的结尾位置。() 标记一个子表达式的开始和结束位置。* 匹配前面的子表达式零次或多次。+ 匹配前面的子表达式一次或多次。. 匹配除换行符 \n 之外的任何单字符。[ 标记一个中括号表达式的开始。? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。&#123; 标记限定符表达式的开始。| 指明两项之间的一个选择。]]></content>
  </entry>
  <entry>
    <title><![CDATA[window.location对象]]></title>
    <url>%2F2018%2F05%2F22%2Fes5(5)%2F</url>
    <content type="text"><![CDATA[属性 hash 从井号(#)开始host 主机名和当前URL的端口号hostname 当前URL的主机名href 完整的URLpathname 当前URL路径部分port 当前URL的端口号protocol 当前URL的协议search 从问号(?)开始的URL]]></content>
  </entry>
  <entry>
    <title><![CDATA[addClass和removeClass区别(jq)]]></title>
    <url>%2F2018%2F05%2F22%2Fjq(addClass%26removeClass)%2F</url>
    <content type="text"><![CDATA[addClass(class|fn) 为每个匹配的元素添加指定的类名。 参数class(类型string) 一个或多个要添加到元素中的CSS类名，请用空格分开function(index, class)(类型function) 此函数必须返回一个或多个空格分隔的class名。接受两个参数，index参数为对象在这个集合中的索引值，class参数为这个对象原先的class属性值。 例如：12345$('p').addClass('selected');$('p').addClass('selected selected');$('p').addClass(function()&#123; return 'item' +$(this).index();&#125;); removeClass(class|fn)从所有匹配的元素中删除全部或者指定的类。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F05%2F22%2Ftest%2F</url>
    <content type="text"><![CDATA[Document div{ border: 10px solid; border-color: #333 transparent #336 #300; width: 0; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2018%2F05%2F22%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 例如：123.box&#123; display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。]]></content>
  </entry>
  <entry>
    <title><![CDATA[css元素]]></title>
    <url>%2F2018%2F05%2F18%2Fcss%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[html中元素分为行内和块级元素 行内元素指的是书写完成后不会自动换行，并且元素没有宽和高。 块级元素写完后会自动换行，有宽高可以修改。 还有一种特殊的元素叫做行内块元素。 行内元素有：heda meat title lable span br a style em b i strong 块级元素有：body from select textarea h1-h6 html tablebutton hr p ol ul dl cnter div 行内块元素常见的有：img input td]]></content>
  </entry>
  <entry>
    <title><![CDATA[css选择器权重]]></title>
    <url>%2F2018%2F05%2F18%2Fcss%E6%9D%83%E9%87%8D%2F</url>
    <content type="text"><![CDATA[CSS优先级权重计算法 例如：123456789101112#id(100) &gt; .class(10) &gt; 标签选择符(1)细分标签内选择符(1000)&gt;ID选择符(100)&gt;Class选择符(10)&gt;元素选择符(1)标签内选择符:元素标签中定义的样式（Style属性）.class||伪类':active,:focus,:hover,:link,:visited,:first-child,:lang'||属性选择符'[title]'(10)标签||伪元素选择符':first-letter,:first-line,:before,:after'(1)通配符'*'(0)!important优先级最高]]></content>
  </entry>
  <entry>
    <title><![CDATA[dl表格]]></title>
    <url>%2F2018%2F05%2F18%2Fdl%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[html dl dt dd标签元素语法结构与使用 1,语法 例如：123456&lt;dl&gt; &lt;dt&gt;列表标题&lt;/dt&gt; &lt;dd&gt;列表内容&lt;/dd&gt; &lt;dd&gt;列表内容&lt;/dd&gt; ...&lt;/dl&gt; 是一组合标签,使用了dt dd最外层就必须使用dl包裹。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES5(04)]]></title>
    <url>%2F2018%2F05%2F14%2Fes5(04)%2F</url>
    <content type="text"><![CDATA[函数 1,概述函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。1)函数的声明JavaScript 有三种声明函数的方法。 例如：1234567891011121314151617181920//function 命令function print(s)&#123; console.log(s);&#125;//函数表达式var print = function(s)&#123; console.log(s);&#125;;//如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。var print = function x()&#123; console.log(typeof x);&#125;;//Function 构造函数var add = new Function( 'x', 'y', 'return x+y'); 2)函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 3)圆括号运算符，return 语句和递归调用函数时，要使用圆括号运算符。 return语句所带的那个表达式，就是函数的返回值。 函数可以调用自身，这就是递归（recursion）。 例如：1234567function fib(num)&#123; if(num ===0) return 0; if(num ===1) return 1; return fib(num-2) + fib(num-1);&#125;fib(6)//8 4)第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。 例如：123456789101112131415function add(x,y)&#123; return x+y;&#125;// 将函数赋值给一个变量var a = add;// 将函数作为参数和返回值function a(op)&#123; return op;&#125;a(add(1,2));等价于a(add)(1,2); 5)函数名的提升 例如：123456789101112131415161718192021222324//代码不会报错，整个函数会像变量声明一样，被提升到代码头部。f();function f();//采用赋值语句定义函数，JavaScript 就会报错。f();var f = function()&#123;&#125;等价于var f;f();f = function()&#123;&#125;//如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。var f = function()&#123; console.log('1');&#125;function f()&#123; console.log('2');&#125;f() 6)不能在条件语句中声明函数 例如：12345678910//不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。if (foo) &#123; function x() &#123;&#125;&#125;try &#123; function x() &#123;&#125;&#125; catch(e) &#123; console.log(e);&#125; 2,函数的属性和方法1)name 属性函数的name属性返回函数的名字。 例如：123456789101112131415function f()&#123;&#125;f.name //fvar f = function ()&#123;&#125;f.name //fvar f = function myName()&#123;&#125;f.name //myNamevar myFunc = function ()&#123;&#125;function test(f)&#123; console.log(f.name);&#125;test(myFunc) //myFunc 2)length 属性 例如：12function f(a,b)&#123;&#125;f.length //2 length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。 3)toString()函数的toString方法返回一个字符串，内容是函数的源码。 例如：123456function f()&#123; a(); b(); c();&#125;f.toString(); 3,函数作用域1)定义作用域（scope）指的是变量存在的范围。Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。 函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。 2)函数内部的变量提升 例如：123456789101112function foo(x)&#123; if(x &gt;100)&#123; var tmp = x - 100; &#125;&#125;等价于function foo(x)&#123; var tmp; if(x &gt;100)&#123; tmp = x - 100; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES5(03)]]></title>
    <url>%2F2018%2F05%2F14%2Fes5(03)%2F</url>
    <content type="text"><![CDATA[错误处理机制 1，Error 实例对象 例如：123var err = new Error('出错了');err.message JavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息。而大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。 例如：123messagenamestack 2,Error的6个派生对象。1)SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。 例如：变量名错误缺少括号 2)ReferenceError 对象ReferenceError对象是引用一个不存在的变量时发生的错误。 例如：使用一个不存在的变量对函数的运行结果或者this赋值 3)RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。 例如：数组长度为负数Number对象的方法参数超出范围函数堆栈超过最大值 4)TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。 例如：对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数调用对象不存在的方法 5)URIError 对象 6)EvalError 对象 3,throw 语句throw语句的作用是手动中断程序执行，抛出一个错误。 例如：123if(x&lt;0)&#123; throw new Error('x 必须为正数');&#125; throw可以抛出任何类型的值 4,try…catch 结构一旦发生错误，程序就中止执行了。JavaScript 提供了try…catch结构，允许对错误进行处理，选择是否往下执行。 例如：123456try &#123; throw new Error('出错了!');&#125; catch (e) &#123; console.log(e.name + ": " + e.message); console.log(e.stack);&#125; 5,finally 代码块try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES5(02)]]></title>
    <url>%2F2018%2F05%2F14%2Fes5(02)%2F</url>
    <content type="text"><![CDATA[数据类型 1,概况JavaScript 的数据类型，共有六种。 例如：12345678910111213141516 number(数值)：整数和小数(1,3.14) string(字符串)：文本(hello world) boolean(布尔值)：(true,false) undefined:未定义 null:空值 object:(对象) ``` 数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。 对象是最复杂的数据类型，又可以分成三个子类型。 #### 例如： ```bash object(狭义的对象) array(数组) function(函数) 2,typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 例如：123typeof(运算符)instanceof(运算符)Object.prototype.toString(方法) typeof运算符可以返回一个值的数据类型。 例如：12345678910111213typeof 123 //numbeltypeof '123' //stringtypeof false //boobeanfunction f()&#123;&#125;typeof f //functiontypeof undefinedw //undefinedtypeof null //object typeof window //objecttypeof &#123;&#125; //objecttypeof [] //object typeof可以用来检查一个没有声明的变量，而不报错。 例如：12v //err:v is not definedtypeof v //undefined 这个特点通常用在判断语句。 例如：12345678//错误的写法if(v)&#123; //...&#125;//正确的写法if(typeof v ==== 'undefined')&#123; //...&#125; 3,null 和 undefined1)概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 例如：123var a = undefined;//或者var a = null; 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 例如：123456789101112131415if(!undefined)&#123; console.log('undefined is false');&#125; if(!null)&#123; console.log('null is false');&#125;if(undefined == null)&#123; console.log('在相等运算符的前提下相等');&#125;if(undefined === null)&#123; console.log('在严格相等运算符的前提下相等');&#125; 核心区别：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 例如：12345Number(undefined) //NaN5 + undefined //NaNNumber(null) //05 + null //5 2)用法和含义返回undefined的典型场景。 例如：12345678910111213141516171819// 变量声明了，但没有赋值。var i;// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x)&#123; return x;&#125;f()// 对象没有赋值的属性var o = new Object();o.p // 函数没有返回值时，默认返回 undefinedfunction f()&#123;&#125;f() 4,布尔值1)下列运算符会返回布尔值： 例如：1234两元逻辑运算符：&amp;&amp;(and) ||(or) 前置逻辑运算符：!(not)相等运算符：=== !== == !=比较运算符：&gt; &gt;= &lt; &lt;= 2)除了下面六个值被转为false，其他值都视为true。 例如：123456undefined nullfalse0NaN''或""]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES5(01)]]></title>
    <url>%2F2018%2F05%2F12%2Fes5(01)%2F</url>
    <content type="text"><![CDATA[语法 一基本语法：1,语句和表达式的区别：1）前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。2)语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 例如：1var a = 4;var b = 5; 分号前面可以没有任何内容，JavaScript引擎将其视为空语句。 例如：1;;; 3)表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 例如：121+2;'abc'; 2,变量1)JavaScript 的变量名区分大小写，A和a是两个不同的变量。2)变量的声明和赋值，是分开的两个步骤。 例如：1234var a = 1;等价于var a;a=1; 3)变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升。 例如：123456console.log(a);var a = 1;这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。var a;console.log(a);//undefineda=1; 3,标识符1)标识符（identifier）指的是用来识别各种值的合法名称。常见的如变量名、函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。2)标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。命名规则：第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 例如：1234567891011 合法arg0_tmpvar 临时变量 = 1；$elem 不合法 1a // 第一个字符不能是数字 23 *** // 标识符不能包含星号 a+b // 标识符不能包含加号 -d // 标识符不能包含减号或连词线 1JavaScript有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 4,注释1)// 这是单行注释2)/ 这是 多行 注释 /5,区块1)JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。6,条件语句1)if 结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。 例如：123if(m === 1)&#123; m = m+1;&#125; 赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 例如：12345 var x = 1; var y = 2;if(x = y)&#123; console.log(x);&#125; 常量不能被赋值。 例如：12if(2=x)&#123;&#125;//报错if(x=2)&#123;&#125;//不报错 2)if…else 结构3)switch结构多个if…else连在一起使用的时候，可以转为使用更方便的switch结构。 例如：123456789101112131415161718var x =2;if(x==0)&#123; console.log(x);&#125;else if(x==1)&#123; console.log(x);&#125;else&#123; console.log(x);&#125;等价于switch语句内部采用的是“严格相等运算符”。switch(x)&#123; case 1:console.log(x); break; case 2:console.log(x); break; default:console.log(x);&#125; 4)三元运算符 ?:如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。 例如：1(条件) ? 表达式1 : 表达式2 7,循环语句1)while 循环 例如：12345var i =0;while(i&lt;100)&#123; console.log(i); i++;&#125; 2)for 循环 例如：123for(var i=0;i&lt;5;i++)&#123; console.log(i);&#125; 3)do…while 循环 例如：123456var a =1;var b =2;do&#123; console.log(a); a++;&#125;while(a&lt;b); 不管条件是否为真，do…while循环至少运行一次。另外，while语句后面的分号注意不要省略。4)break 语句和 continue 语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。break语句用于跳出代码块或循环。 例如：123456var i = 0;while(i &lt; 100) &#123; console.log('i 当前为：' + i); i++; if (i === 10) break; &#125; continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 例如：123456var i = 0;while(i &lt; 100) &#123; i++; if (i%2 === 0) continue; console.log('i 当前为：' + i); &#125; 5)标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置。标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。标签通常与break语句和continue语句配合使用，跳出特定的循环。 例如：1234567top: for(var i=0;i&lt;3;i++)&#123; for(var j=0;j&lt;3;j++)&#123; if(i===1 &amp;&amp; j===1)break top; console.log('i='+i+',j='+j); &#125; &#125; 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[#Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
